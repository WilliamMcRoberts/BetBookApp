@page "/AdminScoresInput"
@attribute [Authorize(Policy = "Admin")]
@using Syncfusion.Blazor.Calendars
@inject ITeamData teamData
@inject IGameData gameData
@inject ITeamRecordData recordData
@inject IBetData betData

<PageTitle>AdminScoresInput</PageTitle>

<div class="input">
    <div class="winner-input">
            <h1 style="margin-left: 1em;margin-top: .5em;" class="title">Update Scores</h1>
        @if(noGame == true)
                {
            <div style="color:red;text-align:center;margin-top:1em;font-size:15px;font-weight:700;margin-right:2em;">*THERE IS NO GAME WITH THAT GAME ID, TRY AGAIN*</div>
        }
        else
        {
            <div style="text-align:center;margin-top:1em;font-size:15px;font-weight:700;margin-right:2em;">ENTER A GAME ID TO SELECT A GAME</div>
        }
        <div class="game-id-box">
            <div style="display: flex;justify-content: space-between;">
                <div>
                    <label>Game Id</label>
                    <input type="number" @bind-value="@GameId" @bind-value:event="oninput"/>
                </div>
                <div>
                    <button class="site-btn btn site-btn-light btn-sm text-uppercase" @onclick="(() => PopulateBasicGameModel(GameId))">Get Game</button>
                </div>
            </div>
        </div>
        <div class="game">
            @if (scoresAdded)
            {
                <div style="margin: 4em 1em;">
                    <h1>Winners have been successfully added!</h1>
                    <h1>You may add more game winners.</h1>
                </div>
            }
            else
            {
                <ul class="game-info">
                    <li class="team-item">Home Team || @BasicGame.HomeTeamName</li>
                    <li class="team-item">Away Team || @BasicGame.AwayTeamName</li>
                    <li class="team-item">Favorite || @BasicGame.FavoriteTeamName</li>
                    <li class="team-item">Underdog || @BasicGame.UnderdogTeamName</li>
                    <li class="team-item">Point Spread || @BasicGame.PointSpread</li>
                </ul>
            }
            <br>
            <label>Favorite Score</label>
            <div class="scores-box">
                <input type="number" @bind-value="@FavoriteScore" @bind-value:event="oninput"/>
            </div>
            <label>Underdog Score</label>
            <div class="scores-box">
                <input type="number" @bind-value="@UnderdogScore" @bind-value:event="oninput"/>
            </div>
            <button @onclick="(() => UpdateGameWinner(FavoriteScore, UnderdogScore))" style="margin-bottom: 2em;margin-top:2em;" class="site-btn btn site-btn-light btn-sm text-uppercase">Submit Scores</button>
        </div>
    </div>
</div>

@code {

    // Id of game
    private int GameId;

    // Basic game of selected game
    private BasicGameModel BasicGame { get; set; } = new();

    // Current game being updated
    private GameModel CurrentGame { get; set; } = new();

    // Favorite team
    private TeamModel? CurrentFavorite { get; set; }

    // Underdog team
    private TeamModel? CurrentUnderdog { get; set; }

    // Home team
    private TeamModel? CurrentHomeTeam { get; set; }

    // Away team
    private TeamModel? CurrentAwayTeam { get; set; }

    // Score of favorite
    private double FavoriteScore;

    // Score of underdog
    private double UnderdogScore;

    // Boolean to check if winners were added
    private bool scoresAdded = false;

    // Boolean to check if current game is null
    private bool noGame = false;

    /// <summary>
    /// Async method updates the scores of the game,
    /// calls the CalculateWinningTeam() method,
    /// adds winning team to database, and calls the
    /// UpdateTeamRecords() method
    /// </summary>
    /// <param name="favoriteScore">
    /// double representing the favorite team score of the current game
    /// </param>
    /// <param name="underdogScore">
    /// double representing the underdog team score of the current game
    /// </param>
    /// <returns></returns>
    private async Task UpdateGameWinner(double favoriteScore, double underdogScore)
    {
        if(CurrentGame is not null)
        {
            if (CurrentGame.Id != 0)
            {
                CurrentGame.FavoriteFinalScore = favoriteScore;
                CurrentGame.UnderdogFinalScore = underdogScore;
                CurrentGame.GameStatus = GameStatus.FINISHED;

                await gameData.UpdateGame(CurrentGame);

                TeamModel? winningTeam =
                    CalculateWinningTeam(CurrentGame, favoriteScore, underdogScore);

                if (winningTeam is not null)
                    await gameData.AddGameWinner(CurrentGame, winningTeam);

                await UpdateBetWinners(favoriteScore, underdogScore);

                scoresAdded = true;

                ClearUpdateWinnersForm();

                await UpdateTeamRecords(favoriteScore, underdogScore);

                noGame = false;
            }

            else
                noGame = true;
        }
    }

    /// <summary>
    /// Async method updates final winner and bet status 
    /// for all bets that were placed on current game
    /// </summary>
    /// <param name="favoriteScore">
    /// double represents the favorite team score
    /// </param>
    /// <param name="underdogScore">
    /// double represents the underdog team score
    /// </param>
    /// <returns></returns>
    private async Task UpdateBetWinners(double favoriteScore, double underdogScore)
    {
        TeamModel? winningTeamForBets =
            CalculateWinningTeamForBet(CurrentGame, favoriteScore, underdogScore);

        List<BetModel> betsOnCurrentGame = 
           (List<BetModel>) await betData.GetAllBetsOnGame(CurrentGame.Id);

        if(winningTeamForBets is not null)
        {
            foreach(BetModel bet in betsOnCurrentGame)
            {
                bet.FinalWinnerId = winningTeamForBets.Id;

                if(winningTeamForBets.Id == bet.ChosenWinnerId)
                    bet.BetStatus = BetStatus.WINNER;

                else
                    bet.BetStatus = BetStatus.LOSER;

                await betData.UpdateBet(bet);
            }
        }

        else
        {
            foreach(BetModel bet in betsOnCurrentGame)
            {
                bet.BetStatus = BetStatus.PUSH;
                bet.FinalWinnerId = 0;

                await betData.UpdateBet(bet);
            }
        }
    }

    /// <summary>
    /// Async method updates team records of
    /// the actual winning  team and actual losing team
    /// </summary>
    /// <param name="favoriteScore">
    /// int representing the favorite team score of the current game
    /// </param>
    /// <param name="underdogScore">
    /// int representing the underdog team score of the current game
    /// </param>
    /// <returns></returns>
    private async Task UpdateTeamRecords(double favoriteScore, double underdogScore)
    {
        TeamModel? actualWinningTeam = new();
        TeamModel? actualLosingTeam = new();

        if (favoriteScore > underdogScore)
        {
            actualWinningTeam = CurrentFavorite;
            actualLosingTeam = CurrentUnderdog;
        }

        else if (favoriteScore < underdogScore)
        {
            actualWinningTeam = CurrentUnderdog;
            actualLosingTeam = CurrentFavorite;
        }

        else if (favoriteScore == underdogScore) 
            actualWinningTeam = null;

        // If game is a draw
        if(actualWinningTeam is null)
        {
            TeamRecordModel? teamFavoriteRecord = await recordData.GetTeamRecord(CurrentFavorite.Id);
            TeamRecordModel? teamUnderdogRecord = await recordData.GetTeamRecord(CurrentUnderdog.Id);

            if(teamFavoriteRecord is not null && teamUnderdogRecord is not null)
            {
                teamFavoriteRecord.Draws += $"{CurrentUnderdog.TeamName}|";
                teamUnderdogRecord.Draws += $"{CurrentFavorite.TeamName}|";

                await recordData.UpdateTeamRecord(teamFavoriteRecord);
                await recordData.UpdateTeamRecord(teamUnderdogRecord);
            }
        }

        // If game is not a draw
        else
        {
            TeamRecordModel? winnerTeamRecord = await recordData.GetTeamRecord(actualWinningTeam.Id);
            TeamRecordModel? loserTeamRecord = await recordData.GetTeamRecord(actualLosingTeam.Id);

            if(winnerTeamRecord is not null && loserTeamRecord is not null)
            {
                winnerTeamRecord.Wins += $"{actualLosingTeam.TeamName}|";
                loserTeamRecord.Losses += $"{actualWinningTeam.TeamName}|";

                await recordData.UpdateTeamRecord(winnerTeamRecord);
                await recordData.UpdateTeamRecord(loserTeamRecord);
            }
        }
    }

    /// <summary>
    /// Method calculates and returns winning team of current game
    /// </summary>
    /// <param name="game">
    /// GameModel representing the current game
    /// </param>
    /// <param name="favoriteScore">
    /// int representing the favorite team score of the current game
    /// </param>
    /// <param name="underdogScore">
    /// int representing the underdog team score of the current game
    /// </param>
    /// <returns name="winner">
    /// TeamModel representing the winner of the current game
    /// </returns>
    private TeamModel CalculateWinningTeam(GameModel game, double favoriteScore, double underdogScore)
    {
        TeamModel? winner = new();

        winner = (favoriteScore == underdogScore) ? null :
                 (favoriteScore > underdogScore) ? CurrentFavorite : CurrentUnderdog;

        return winner;
    }

    /// <summary>
    /// Method calculates and returns the winning team
    /// after factoring in the point spread
    /// </summary>
    /// <param name="game">
    /// GameModel representing the current game
    /// </param>
    /// <param name="favoriteScore">
    /// int representing the favorite team score
    /// </param>
    /// <param name="underdogScore">
    /// int representing the underdog team score
    /// </param>
    /// <returns name="winner">
    /// winner of the game after factoring in the point spread
    /// </returns>
    private TeamModel CalculateWinningTeamForBet(GameModel game, double favoriteScore, double underdogScore)
    {
        double pointSpread = CurrentGame.PointSpread;
        double favoriteScoreMinusPointSpread = favoriteScore - pointSpread;

        TeamModel? winner = new();

        winner = (favoriteScoreMinusPointSpread == underdogScore) ? null :
                 (favoriteScoreMinusPointSpread > underdogScore) ? CurrentFavorite : CurrentUnderdog;

        return winner;
    }

    /// <summary>
    /// Method clears update winners form
    /// </summary>
    private void ClearUpdateWinnersForm()
    {
        GameId = 0;
        FavoriteScore = 0;
        UnderdogScore = 0;
    }

    /// <summary>
    /// Async method to populate basic game model
    /// for current game being updated
    /// </summary>
    /// <param name="gameId">int Id of current game</param>
    /// <returns></returns>
    private async Task PopulateBasicGameModel(int gameId)
    {
        scoresAdded = false;

        CurrentGame = await gameData.GetGame(gameId);

        if (CurrentGame is not null)
        {
            CurrentHomeTeam = await teamData.GetTeam(CurrentGame.HomeTeamId);
            CurrentAwayTeam = await teamData.GetTeam(CurrentGame.AwayTeamId);
            CurrentFavorite = await teamData.GetTeam(CurrentGame.FavoriteId);
            CurrentUnderdog = await teamData.GetTeam(CurrentGame.UnderdogId);

            BasicGame.HomeTeamName = CurrentHomeTeam.TeamName;
            BasicGame.AwayTeamName = CurrentAwayTeam.TeamName;
            BasicGame.FavoriteTeamName = CurrentFavorite.TeamName;
            BasicGame.UnderdogTeamName = CurrentUnderdog.TeamName;
            BasicGame.PointSpread = CurrentGame.PointSpread;
        }

        else
        {
            noGame = true;
            ClearUpdateWinnersForm();
        }
    }
}
